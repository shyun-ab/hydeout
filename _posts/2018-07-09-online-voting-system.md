---

layout: post

title: "Distributed System - Online Voting System"

categories:

  - Projects

commit: true

excerpt_separator:  <!--more-->

---



- 개요: 분산시스템및컴퓨팅 수업에서 진행한 팀 프로젝트

- 목적: 분산 시스템 구축, 블록체인 활용

- 진행 기간: 2018.05.11 ~ 2018.06.27 (약 7주)

- 개발 인원: 3명 (건국대학교 컴퓨터공학과)

<br><br>

## 개발 환경

- 사용 언어 : **Java** (jdk 9)

- 운영체제 : **Window 10**, MacOS 10.13

- 개발 도구 : **Eclipse Oxygen**, IntelliJ

- 빌드 : **Gradle**

- 형상 관리 : **Github**

- 라이브러리 : Gson, apache-commons-codec

<br><br>

## 핵심 기술

- 블록체인
![BlockChain](https://github.com/shyun-ab/shyun-ab.github.io/blob/master/_screenshots/blockchain.png?raw=true)

: 블록에 데이터를 담아 체인 형태로 연결, 수많은 컴퓨터에 동시에 이를 복제해 저장하는 분산형 데이터 저장 기술이다. 공공 거래 장부라고도 부른다.<br>
중앙 집중형 서버에 거래 기록을 보관하지 않고 거래에 참여하는 모든 사용자에게 거래 내역을 보내 주며, 거래 때마다 모든 거래 참여자들이 정보를 공유하고 이를 대조해 데이터 위조나 변조를 할 수 없도록 돼 있다. 해시 값을 포함하는 방식으로 이전 블록과 연결되어 있다.<br>

<br>

- 합의 알고리즘 PBFT(Practical Byzantine Fault Tolerance)
![PBFT](https://github.com/shyun-ab/shyun-ab.github.io/blob/master/_screenshots/PBFT.png?raw=true)

: PBFT는 PoW나 PoS와 마찬가지로 Byzantine Fault 모델이지만 PoW나 PoS의 단점인 finality의 불확실성과 성능문제를 해결한 것이다. 다수결의 원칙으로 대표자 노드들 중 일정비율(⅔)이상의 노드가 합의하면 블록이 검증되어 체인에 연결된다. <br>
악의적 공격으로 얻는 이익보다 공격에 쓰이는 비용을 높게 만들어 보안성을 높였다.<br>
PBFT는 네트워크의 모든 참가자를 미리 알고 있어야 한다. (이는 전자투표에서 전체 투표가능한 유권자를 미리 파악하고 등록해야 하는 것과 유사하다.) 참가자중 1명이 Primary가 되고 자신을 포함한 모든 참가자에게 요청을 보낸다. 그 요청에 대한 결과를 집계한 뒤 다수의 값을 사용해 블록을 확정한다. 부정한 노드 수를 n개라고 하면 노드 수는 (3n+1)개여야 하며, 확정에는 (n+1)개 이상의 노드가 필요하다.<br>

<br>

- RSA 암호화

: 소인수분해의 어려움을 이용한 암호화 방식으로 암호화 및 디지털 서명 용도로 사용이 가능하다. 송신자는 수신자로부터 받은 공개키로 암호화하고, 수신자는 자신의 개인키로 복호화 한다. RSA과정에서 전자서명은 송신자가 자신의 개인키로 서명을 하고, 서명의 복호화는 송신자의 공개키로 수행한다. 투표 정보는 본인의 개인키로 암호화가 되고, 암호화된 투표정보는 공개키로 복호화되어 투표 결과에 집계된다.


<br><br>


## 구성

- 전체 시스템 구성도
![system](https://github.com/shyun-ab/shyun-ab.github.io/blob/master/_screenshots/system.png?raw=true)
투표자는 투표소로 가 자신의 신원을 확인하게 되면 개인키를 부여받게 된다. 투표정보는 개인키로 암호화 된 후 노드로 전달 된다. 노드는 노드 간 블록 검증을 통해 유효성을 체크한다. 일정 수의 투표정보가 모이게 되면 블록을 생성한다. 투표자는 실시간 투표 결과를 확인 할 수 있다. 블록에 저장된 공개키를 이용해 투표정보를 복호화 한다.

<br>

- UML 다이어그램
<br>
![uml](https://github.com/shyun-ab/shyun-ab.github.io/blob/master/_screenshots/uml.png?raw=true)


<br><br>


## 시나리오

- 투표 과정
1. 신분증으로 투표 자격이 있는지 확인
2. 문제가 없으면 키 쌍 생성 및 개인키 발급
3. 개인키는 투표 내용을 암호화한 후 폐기, 공개키는 블록에 저장
4. 암호화된 투표 내용은 노드로 전달, 노드 간 검증은 PBFT 합의 알고리즘 이용
5. 투표 내용이 충분히 많이 모이면 하나의 블록 생성(현재는 빠른 테스트를 위해 투표 2회 실시마다 생성)
6. 블록끼리 이전 해시값으로 검증

<br>

- 투표 결과 조회
1. 블록에 저장된 공개키로 투표 내용을 복호화하여 표를 집계
2. 후보자 별 득표 수 출력

<br>

- 동영상 시연 내용
1. 누군가 악의적으로 블록들을 삭제 시도할 때
-> 여러 개의 노드들이 서로 동기화되어 한 노드의 블럭이 삭제되어도 다시 복구된다.
2. 해시값 변조를 시도할 때
-> 이전 해시값에 대한 변조를 시도해도 다른 노드들과의 검증을 통해 원래의 값으로 복구된다.


<br><br>


## 기대효과 및 향후 계획

- 기존의 투표방식에 비해 저렴한 비용으로 투명하고 빠른 전자투표가 가능하다.
- 신상정보-투표내용을 저장하지 않아 익명성이 보장된다.
- 투표 진행과정과 결과가 투명하게 공개된다.
- 실시간 득표 수를 확인 가능하고 따로 개표 과정이 필요하지 않다.
- 블록체인 기반 전자투표 방식을 사용하여 해킹과 조작이 어렵다.
  
- 웹 기반 선거 시스템으로 확장할 수 있다.
- 현재는 과 회장 선거 정도의 투표소가 적은 수로 한정되어 있는 소규모 투표를 생각했으나, 보다 큰 규모의 선거나 모바일 선거 등을 고려하여 1인 1투표와 익명성을 동시에 만족할 투표 시스템으로 보완해보고 싶다.

<br><br>